name: Deploy to AWS EC2 with HTTPS

on:
  push:
    branches: [ main ]  # Adjust this to your main branch name if different

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Install dependencies
      run: npm ci

    - name: Create .env file
      run: |
        echo "PORT=${{ secrets.PORT }}" >> .env
        echo "FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}" >> .env
        echo "FIREBASE_PRIVATE_KEY=${{ secrets.FIREBASE_PRIVATE_KEY }}" >> .env
        echo "FIREBASE_CLIENT_EMAIL=${{ secrets.FIREBASE_CLIENT_EMAIL }}" >> .env
        echo "USER_JWT=${{ secrets.USER_JWT }}" >> .env
        echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> .env
        echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> .env
        echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> .env
        echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
        echo "RAZ_KEY_ID=${{ secrets.RAZ_KEY_ID }}" >> .env
        echo "RAZ_KEY_SECRET=${{ secrets.RAZ_KEY_SECRET }}" >> .env
        echo "RAZ_WEBHOOK_SECRET=${{ secrets.RAZ_WEBHOOK_SECRET }}" >> .env
        echo "SMS_API_ID=${{ secrets.SMS_API_ID }}" >> .env
        echo "SMS_API_PASSWORD=${{ secrets.SMS_API_PASSWORD }}" >> .env
        echo "SMS_SENDER_ID=${{ secrets.SMS_SENDER_ID }}" >> .env
        echo "SMS_TEMPLATE_ID=${{ secrets.SMS_TEMPLATE_ID }}" >> .env
        echo "ONESIGNAL_APP_ID=${{ secrets.ONESIGNAL_APP_ID }}" >> .env
        echo "ONESIGNAL_REST_API_KEY=${{ secrets.ONESIGNAL_REST_API_KEY }}" >> .env
        # Add your domain name as an environment variable
        echo "DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}" >> .env

    - name: Set up SSH key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Setup SSH config
      run: |
        mkdir -p ~/.ssh
        echo "Host ec2-instance" >> ~/.ssh/config
        echo "  HostName ${{ secrets.EC2_HOST }}" >> ~/.ssh/config
        echo "  User ${{ secrets.EC2_USER }}" >> ~/.ssh/config
        echo "  StrictHostKeyChecking no" >> ~/.ssh/config

    - name: Create deployment package
      run: |
        # Create a clean directory for deployment
        mkdir -p /tmp/deploy
        
        # Copy necessary files to the deployment directory
        # Using cp instead of rsync to avoid the file changing issue
        cp -R ./* /tmp/deploy/
        cp .env /tmp/deploy/
        
        # Remove unnecessary files
        rm -rf /tmp/deploy/.git /tmp/deploy/.github /tmp/deploy/node_modules
        
        # Create archive from deployment directory
        cd /tmp
        tar -czf deploy.tar.gz -C deploy .

    - name: Deploy to EC2
      run: |
        # Copy files to EC2
        scp /tmp/deploy.tar.gz ec2-instance:~/counselling/Backend/deploy.tar.gz
        
        # Execute remote deployment script
        ssh ec2-instance "
          cd ~/counselling/Backend
          
          # Debug - show current directory and files
          pwd
          ls -la
          
          # Create directory if it doesn't exist
          mkdir -p User_api
          
          # Extract files - use absolute path to be sure
          tar -xzf ~/counselling/Backend/deploy.tar.gz -C User_api
          
          # Install dependencies
          cd User_api
          npm ci --production
          
          # Set up SSL certificate (only if needed)
          if [ ! -d \"/etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}\" ]; then
            sudo apt-get update
            sudo apt-get install -y certbot
            sudo certbot certonly --standalone -d ${{ secrets.DOMAIN_NAME }} -d www.${{ secrets.DOMAIN_NAME }} --non-interactive --agree-tos -m ${{ secrets.SSL_EMAIL }}
          fi
          
          # Create HTTPS config if it doesn't exist
          if [ ! -f \"https-config.js\" ]; then
            echo 'import fs from \"fs\";
            import path from \"path\";
            
            const certPath = \"/etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}\";
            
            export {
              key: fs.readFileSync(path.join(certPath, \"privkey.pem\")),
              cert: fs.readFileSync(path.join(certPath, \"fullchain.pem\"))
            };' > https-config.js
          fi
          
          # Restart service using PM2 with ecosystem config
          if [ -f \"ecosystem.config.js\" ]; then
            # Copy ecosystem config if it doesn't exist in the target directory
            cp ecosystem.config.js User_api/ 2>/dev/null || true
          fi
          
          cd User_api
          if pm2 list | grep -q \"user-api\"; then
            pm2 restart ecosystem.config.js --update-env
          else
            pm2 start ecosystem.config.js
          fi
          
          # Set up SSL renewal cron job
          (crontab -l 2>/dev/null; echo \"0 3 * * * sudo certbot renew --quiet\") | sort - | uniq - | crontab -
          
          # Remove the tar file after successful deployment
          rm ~/counselling/Backend/deploy.tar.gz
        "